from operator import itemgetter


def invert_spans(spans, span_min, span_max):
    """Inverts the list of provided spans and clamps the inversion between the specified minimum and maximum.

    Return a list of spans that are the result of the inversion of the provide spans clamped by the provided range.

    :param spans: List of spans [(min, max), ..., ] to invert
    :param span_min: Minimum value to clamp the inversion against
    :param span_max: Maximum value to clamp the inversion against
    :return: List of spans [(min, max), ..., ] generated by inverting the provided spans
    """
    if spans is None:
        raise ValueError('spans cannot be None')
    if span_max < span_min:
        raise ValueError('span max must be greater than or equal to span min')

    # Empty list is just the span minimum and span maximum provided.
    if len(spans) == 0:
        return [(span_min, span_max)]

    # Sort and merge the spans.
    spans = merge_spans(spans)

    # Check that the span minimum and maximum range fits the span list.
    if spans[0][0] < span_min:
        raise ValueError('span min must be less than or equal to the smallest span start')
    if spans[-1][1] > span_max:
        raise ValueError('span max must be greater than or equal to the largest span end')

    inverted = []

    # Keep the inverted list sorted by ordering operations.

    # Add the span minimum to span list minimum tuple if necessary.
    if spans[0][0] != span_min:
        inverted.append((span_min, spans[0][0]))

    # Invert all spans in the span list.
    i = 0
    while i < len(spans) - 1:
        s = spans[i]
        t = spans[i + 1]
        inverted.append((s[1], t[0]))
        i += 1

    # Add the span list maximum to span maximum tuple if necessary.
    if spans[-1][1] != span_max:
        inverted.append((spans[-1][1], span_max))

    return inverted


def merge_spans(spans):
    """Sorts and merges a list of spans.

    Return a list of spans that are the result of sorting and merging the provided spans.

    :param spans: List of spans [(min, max), ..., ] to sort and merge
    :return: List of spans [(min, max), ..., ] generated by sorting and merging the provided spans
    """
    if spans is None:
        raise ValueError('spans cannot be None')

    # Pre-sort the span list by the first item in each tuple.
    spans = sorted(spans, key=itemgetter(0))

    # Remove any empty spans.
    spans = [span for span in spans if span[0] != span[1]]

    # List of merged spans as tuples.
    merged = []

    # Loop through all spans, attempting to merge them.
    i = 0
    while i < len(spans):
        # Pick a span to attempt to merge others into.
        current_span = spans[i]
        current_min = current_span[0]
        current_max = current_span[1]
        if current_max < current_min:
            raise ValueError('max must be greater than or equal to min')
        # Loop through all other remaining spans.
        j = i + 1
        while j < len(spans):
            # Pick a candidate span to attempt to merge into current span.
            candidate_span = spans[j]
            candidate_min = candidate_span[0]
            candidate_max = candidate_span[1]
            if candidate_max < candidate_min:
                raise ValueError('max must be greater than or equal to min')
            # If the candidate span overlaps or is adjacent, merge it.
            if current_min <= candidate_max and candidate_min <= current_max:
                # Select the smallest minimum and largest maximum of the two spans.
                # The merge result becomes the current span.
                current_span = (current_min if current_min <= candidate_min else candidate_min, current_max if current_max >= candidate_max else candidate_max)
                current_min = current_span[0]
                current_max = current_span[1]
                i += 1
                j += 1
            # Could not merge candidate span.
            else:
                break
        i += 1
        merged.append(current_span)

    return merged


class SpanSet:
    def __init__(self, spans=[]):
        """Create a new SpanSet instance.

        :param spans: List of spans [(min, max), ..., ] to initialize the set with
        :return: SpanSet
        """
        self.spans = merge_spans(spans)


    def add(self, span):
        """Adds a single span to the span set.

        Triggers a sort and merge of the span set.

        :param span: Span (min, max) to add to the span set
        :return: None
        """
        self.spans.append(span)
        self.spans = merge_spans(self.spans)


    def inside(self, value):
        """Checks if a value intersects the span set.

        :param value: Value to check for intersection with the set
        :return: True if the value intersects the set; otherwise, False
        """
        for s in self.spans:
            if s[0] <= value < s[1]:
                return True
        return False


    def invert(self, span_min, span_max):
        """Inverts the span set and returns a new span set.

        :param span_min: Minimum value to clamp the inversion against
        :param span_max: Maximum value to clamp the inversion against
        :return: SpanSet that is the result of the inversion of this SpanSet
        """
        return SpanSet(invert_spans(self.spans, span_min, span_max))
